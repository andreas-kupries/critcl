'\"
'\" Generated from file 'critcl_objtype\&.man' by tcllib/doctools with format 'nroff'
'\" Copyright (c) 2011-2018 Andreas Kupries
'\"
.TH "critcl::objtype" n 0 doc "C Runtime In Tcl (CriTcl)"
.\" The -*- nroff -*- definitions below are for supplemental macros used
.\" in Tcl/Tk manual entries.
.\"
.\" .AP type name in/out ?indent?
.\"	Start paragraph describing an argument to a library procedure.
.\"	type is type of argument (int, etc.), in/out is either "in", "out",
.\"	or "in/out" to describe whether procedure reads or modifies arg,
.\"	and indent is equivalent to second arg of .IP (shouldn't ever be
.\"	needed;  use .AS below instead)
.\"
.\" .AS ?type? ?name?
.\"	Give maximum sizes of arguments for setting tab stops.  Type and
.\"	name are examples of largest possible arguments that will be passed
.\"	to .AP later.  If args are omitted, default tab stops are used.
.\"
.\" .BS
.\"	Start box enclosure.  From here until next .BE, everything will be
.\"	enclosed in one large box.
.\"
.\" .BE
.\"	End of box enclosure.
.\"
.\" .CS
.\"	Begin code excerpt.
.\"
.\" .CE
.\"	End code excerpt.
.\"
.\" .VS ?version? ?br?
.\"	Begin vertical sidebar, for use in marking newly-changed parts
.\"	of man pages.  The first argument is ignored and used for recording
.\"	the version when the .VS was added, so that the sidebars can be
.\"	found and removed when they reach a certain age.  If another argument
.\"	is present, then a line break is forced before starting the sidebar.
.\"
.\" .VE
.\"	End of vertical sidebar.
.\"
.\" .DS
.\"	Begin an indented unfilled display.
.\"
.\" .DE
.\"	End of indented unfilled display.
.\"
.\" .SO ?manpage?
.\"	Start of list of standard options for a Tk widget. The manpage
.\"	argument defines where to look up the standard options; if
.\"	omitted, defaults to "options". The options follow on successive
.\"	lines, in three columns separated by tabs.
.\"
.\" .SE
.\"	End of list of standard options for a Tk widget.
.\"
.\" .OP cmdName dbName dbClass
.\"	Start of description of a specific option.  cmdName gives the
.\"	option's name as specified in the class command, dbName gives
.\"	the option's name in the option database, and dbClass gives
.\"	the option's class in the option database.
.\"
.\" .UL arg1 arg2
.\"	Print arg1 underlined, then print arg2 normally.
.\"
.\" .QW arg1 ?arg2?
.\"	Print arg1 in quotes, then arg2 normally (for trailing punctuation).
.\"
.\" .PQ arg1 ?arg2?
.\"	Print an open parenthesis, arg1 in quotes, then arg2 normally
.\"	(for trailing punctuation) and then a closing parenthesis.
.\"
.\"	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
.if t .wh -1.3i ^B
.nr ^l \n(.l
.ad b
.\"	# Start an argument description
.de AP
.ie !"\\$4"" .TP \\$4
.el \{\
.   ie !"\\$2"" .TP \\n()Cu
.   el          .TP 15
.\}
.ta \\n()Au \\n()Bu
.ie !"\\$3"" \{\
\&\\$1 \\fI\\$2\\fP (\\$3)
.\".b
.\}
.el \{\
.br
.ie !"\\$2"" \{\
\&\\$1	\\fI\\$2\\fP
.\}
.el \{\
\&\\fI\\$1\\fP
.\}
.\}
..
.\"	# define tabbing values for .AP
.de AS
.nr )A 10n
.if !"\\$1"" .nr )A \\w'\\$1'u+3n
.nr )B \\n()Au+15n
.\"
.if !"\\$2"" .nr )B \\w'\\$2'u+\\n()Au+3n
.nr )C \\n()Bu+\\w'(in/out)'u+2n
..
.AS Tcl_Interp Tcl_CreateInterp in/out
.\"	# BS - start boxed text
.\"	# ^y = starting y location
.\"	# ^b = 1
.de BS
.br
.mk ^y
.nr ^b 1u
.if n .nf
.if n .ti 0
.if n \l'\\n(.lu\(ul'
.if n .fi
..
.\"	# BE - end boxed text (draw box now)
.de BE
.nf
.ti 0
.mk ^t
.ie n \l'\\n(^lu\(ul'
.el \{\
.\"	Draw four-sided box normally, but don't draw top of
.\"	box if the box started on an earlier page.
.ie !\\n(^b-1 \{\
\h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.el \}\
\h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.\}
.fi
.br
.nr ^b 0
..
.\"	# VS - start vertical sidebar
.\"	# ^Y = starting y location
.\"	# ^v = 1 (for troff;  for nroff this doesn't matter)
.de VS
.if !"\\$2"" .br
.mk ^Y
.ie n 'mc \s12\(br\s0
.el .nr ^v 1u
..
.\"	# VE - end of vertical sidebar
.de VE
.ie n 'mc
.el \{\
.ev 2
.nf
.ti 0
.mk ^t
\h'|\\n(^lu+3n'\L'|\\n(^Yu-1v\(bv'\v'\\n(^tu+1v-\\n(^Yu'\h'-|\\n(^lu+3n'
.sp -1
.fi
.ev
.\}
.nr ^v 0
..
.\"	# Special macro to handle page bottom:  finish off current
.\"	# box/sidebar if in box/sidebar mode, then invoked standard
.\"	# page bottom macro.
.de ^B
.ev 2
'ti 0
'nf
.mk ^t
.if \\n(^b \{\
.\"	Draw three-sided box if this is the box's first page,
.\"	draw two sides but no top otherwise.
.ie !\\n(^b-1 \h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.el \h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.\}
.if \\n(^v \{\
.nr ^x \\n(^tu+1v-\\n(^Yu
\kx\h'-\\nxu'\h'|\\n(^lu+3n'\ky\L'-\\n(^xu'\v'\\n(^xu'\h'|0u'\c
.\}
.bp
'fi
.ev
.if \\n(^b \{\
.mk ^y
.nr ^b 2
.\}
.if \\n(^v \{\
.mk ^Y
.\}
..
.\"	# DS - begin display
.de DS
.RS
.nf
.sp
..
.\"	# DE - end display
.de DE
.fi
.RE
.sp
..
.\"	# SO - start of list of standard options
.de SO
'ie '\\$1'' .ds So \\fBoptions\\fR
'el .ds So \\fB\\$1\\fR
.SH "STANDARD OPTIONS"
.LP
.nf
.ta 5.5c 11c
.ft B
..
.\"	# SE - end of list of standard options
.de SE
.fi
.ft R
.LP
See the \\*(So manual entry for details on the standard options.
..
.\"	# OP - start of full description for a single option
.de OP
.LP
.nf
.ta 4c
Command-Line Name:	\\fB\\$1\\fR
Database Name:	\\fB\\$2\\fR
Database Class:	\\fB\\$3\\fR
.fi
.IP
..
.\"	# CS - begin code excerpt
.de CS
.RS
.nf
.ta .25i .5i .75i 1i
..
.\"	# CE - end code excerpt
.de CE
.fi
.RE
..
.\"	# UL - underline word
.de UL
\\$1\l'|0\(ul'\\$2
..
.\"	# QW - apply quotation marks to word
.de QW
.ie '\\*(lq'"' ``\\$1''\\$2
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\$2
..
.\"	# PQ - apply parens and quotation marks to word
.de PQ
.ie '\\*(lq'"' (``\\$1''\\$2)\\$3
.\"" fix emacs highlighting
.el (\\*(lq\\$1\\*(rq\\$2)\\$3
..
.\"	# QR - quoted range
.de QR
.ie '\\*(lq'"' ``\\$1''\\-``\\$2''\\$3
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\-\\*(lq\\$2\\*(rq\\$3
..
.\"	# MT - "empty" string
.de MT
.QW ""
..
.BS
.SH NAME
critcl::objtype \- CriTcl Utilities: Custom Tcl_ObjTypes
.SH SYNOPSIS
package require \fBTcl  8\&.4\fR
.sp
package require \fBcritcl  ?3\&.1?\fR
.sp
package require \fBcritcl::objtype  ?0?\fR
.sp
\fB::critcl::objtype define\fR \fIname\fR \fIscript\fR
.sp
\fBsupport\fR \fIcode\fR
.sp
\fBintrep\fR \fIname\fR
.sp
\fBfromobj\fR \fIname\fR
.sp
\fBnewobj\fR \fIname\fR
.sp
\fBapi\fR \fIname\fR
.sp
\fBconstructor\fR \fIcode\fR
.sp
\fBget\fR \fIcode\fR
.sp
\fBcopy\fR \fIcode\fR
.sp
\fBdestructor\fR \fIcode\fR
.sp
\fBstringify\fR \fIcode\fR
.sp
\fBfrom-any\fR \fIcode\fR
.sp
\fBstubs\fR
.sp
.BE
.SH DESCRIPTION
.PP
\fIC Runtime In Tcl\fR, or \fICriTcl\fR , is a system for compiling C code
embedded in Tcl on the fly and either loading the resulting objects into Tcl for
immediate use or packaging them for distribution\&.  Use \fICriTcl\fR to improve
performance by rewriting in C those routines that are performance bottlenecks\&.
.PP
This document is the reference manpage for the \fBcritcl::objtype\fR
package\&. This package provides convenience commands for advanced
functionality built on top of the critcl core\&.
.PP
While Tcl comes with a variety of useful value types
(\fBTcl_ObjType\fR) built into the core there are situations which
are best dealt with using a custom Tcl_ObjType to handle the special
values it came with\&.
.PP
With this package a developer can focus on the core of the
custom value handling, i\&.e\&. allocation, conversion into and out of
strings, release, without having to deal with the boilerplate around
it\&.
.PP
Its intended audience are mainly developers wishing to write
Tcl packages with embedded C code\&.
.PP
This package resides in the Core Package Layer of CriTcl\&.
.PP
.PS
.nf
+----------------+
|Applications    |
| critcl         |
| critcl::app    |
+----------------+

*================*
|Core Packages   |
| critcl         |
| critcl::util   |
*================*

+----------------+
|Support Packages|
| stubs::*       |
| md5, platform  |
|  \&.\&.\&.           |
+----------------+

.fi
.PE
.PP
.SH API
.TP
\fB::critcl::objtype define\fR \fIname\fR \fIscript\fR
This command creates C code containing a static \fBTcl_ObjType\fR
structure and associated functions implementing a custom value type
for Tcl\&.
.sp
This creation is guided by the definition commands in
\fIscript\fR specifying the various parts of the type\&. The available
commands are documented after this\&.
.sp
The result of the command is an empty string\&.
.sp
The actual results are found in the header file generated by
the command\&.
.TP
\fBsupport\fR \fIcode\fR
This command specifies general supporting C code for the type\&. The
code fragment is global, and placed between the declarations and
definitions of the Tcl_ObjType (structures, functions)\&.
.sp
The result of the command is an empty string\&.
.TP
\fBintrep\fR \fIname\fR
This command specifies the C type to use for the internal
representation of values\&. The type has to be known or declared before
the function definitions\&. The \fBsupport\fR command is a good place
for that, if the type is not builtin C type\&.
.TP
\fBfromobj\fR \fIname\fR
This command specifies the name of the function extracting a C value
of type \fBintrep\fR (see above) from a \fBTcl_Obj*\fR\&.
.sp
If not specified the generator falls back to "\fIname\fRFromObj"
using the \fIname\fR from \fB::critcl::objtype define\fR\&.
.sp
The C signature of the function is
.CS


    int <name> (Tcl_Interp* interp, Tcl_Obj* obj, <intrep>* value);

.CE
.IP
The \fBget\fR command specifies the parts of the function body which
are not boilerplate\&.
.sp
The result of the command is an empty string\&.
.TP
\fBnewobj\fR \fIname\fR
This command specifies the name of the function creating a
\fBTcl_Obj*\fR from a C value of type \fBintrep\fR (see above)\&.
.sp
If not specified the generator falls back to "\fIname\fRNewObj"
using the \fIname\fR from \fB::critcl::objtype define\fR\&.
.sp
The C signature of the function is
.CS


    Tcl_Obj* <name> (<intrep>* value);

.CE
.IP
The \fBconstructor\fR command specifies the parts of the function body
which are not boilerplate\&.
.sp
The result of the command is an empty string\&.
.TP
\fBapi\fR \fIname\fR
This command is a convenience command performing the actions of both
\fBfromobj\fR and \fBnewobj\fR\&.
.sp
The result of the command is an empty string\&.
.TP
\fBconstructor\fR \fIcode\fR
This command specifies how a C value of type \fBintrep\fR is converted
into a \fBTcl_Obj*\fR\&.
This is the part of the \fBnewobj\fR function which is not boiler
plate\&.
.sp
The code has access to the two variables \fBobj\fR and
\fBvalue\fR\&. The first refers to a newly allocated \fBTcl_Obj*\fR to
fill, and the second contains the value to convert\&.
.sp
If this code is not specified the generator falls back to
casting the value to a \fBvoid*\fR before copying it into the
\fBptr1\fR field of the \fBTcl_Obj*\fR\&.
.sp
The result of the command is an empty string\&.
.TP
\fBget\fR \fIcode\fR
This command specifies how a C value of type \fBintrep\fR is retrieved
from a \fBTcl_Obj*\fR\&.
This is the part of the \fBfromobj\fR function which is not boiler
plate\&.
.sp
The code has access to the three variables \fBinterp\fR,
\fBobj\fR and \fBvalue\fR\&.  The first is a \fBTcl_Interp*\fR of the
interpreter we are in, the second is the \fBTcl_Obj*\fR we query, and
the last a pointer to the destination to store the retrieved value
into\&.
.sp
If this code is not specified the generator falls back to
casting the value of the \fBobj\fR's \fBptr1\fR to the \fBintrep\fR
type and then copying the result to the destination\&.
.sp
Note that shimmering the \fBobj\fR to this type, if it does
not have that type, is part of the standard behaviour of the function\&.
This makes use of the conversion code specified by \fBparse\fR\&.
.sp
The result of the command is an empty string\&.
.TP
\fBcopy\fR \fIcode\fR
This command specifies how a \fBTcl_Obj*\fR of this type is
duplicated, i\&.e\&. copied\&.
.sp
The code has access to two variables, \fBobj\fR and
\fBdupobj\fR\&. The first references the \fBTcl_Obj*\fR to duplicate,
and the second references a newly allocated, empty \fBTcl_Obj*\fR to
fill with the duplicated \fBintrep\fR\&.
.sp
If this code is not specified the copy constructor is left as
\fBNULL\fR and the Tcl core standard behaviour applies, which simply
copies the intrep over\&.
.sp
The result of the command is an empty string\&.
.TP
\fBdestructor\fR \fIcode\fR
This command specifies how a \fBTcl_Obj*\fR of this type releases it
\fBintrep\fR when the core destroys it\&.
.sp
The code has access to a single variable, \fBobj\fR, which
references the \fBTcl_Obj*\fR being released\&.
.sp
If this code is not specified the destructor is left as
\fBNULL\fR and the Tcl core standard behaviour applies, which simply
does nothing\&.
.sp
The result of the command is an empty string\&.
.TP
\fBstringify\fR \fIcode\fR
This command specifies how to construct a string representation
from the \fBintrep\fR of this type\&.
.sp
The code has access to a single variable, \fBobj\fR, which
references the \fBTcl_Obj*\fR whose string representation has to be
filled in\&.
.sp
If this code is not specified then \fInothing\fR is done\&. In
other words, values of this type have no string representation\&.  This
not only prevents printing such values, but also the conversion to any
other \fBTcl_ObjType\fR using an intermediate string representation
as part of shimmering to it\&.
.sp
Note the supporting macros \fBOT_STR_SET\fR, \fBOT_STR_DUP\fR,
and \fBOT_STR_DS\fR\&. See the \fBSupporting definitions\fR\&.
.sp
The result of the command is an empty string\&.
.TP
\fBfrom-any\fR \fIcode\fR
This command specifies how to shimmer a \fBTcl_Obj*\fR from whatever
current type it has to this type\&.
.sp
The code has access to the three variables \fBinterp\fR,
\fBobj\fR and \fBvalue\fR\&.  The first is a \fBTcl_Interp*\fR of the
interpreter we are in, the second is the \fBTcl_Obj*\fR to shimmer,
and the last is the place where to construct the new \fBintrep\fR\&.
.sp
The function using this code will call this first before
releasing the old internal representation and at last using the
\fBconstructor\fR code to store the new internal representation found
in \fBvalue\fR into the object\&.
.sp
The result of the command is an empty string\&.
.TP
\fBstubs\fR
This command tells the generator that the \fBfromobj\fR and
\fBnewobj\fR functions of this type are to be made public,
i\&.e\&. exported through the stubs table of the package the code will be
made a part of\&.
.PP
.SH "SUPPORTING DEFINITIONS"
All \fIcode\fR argument not only have access to the variables listed
in their documentation above, the definitions from the \fBsupport\fR
cmd, but also to
.TP
\fB@have_destructor@\fR
Boolean (\fB0\fR/\fB1\fR)\&.
True indicates that the \fBdestructor\fR was specified\&.
.TP
\fB@have_copy@\fR
Boolean (\fB0\fR/\fB1\fR)\&.
True indicates that the \fBcopy\fR constructor was specified\&.
.TP
\fB@fun_destructor@\fR
Name of the destructor function\&.
.TP
\fB@fun_copy@\fR
Name of the copy constructor function\&.
.TP
\fB@fun_stringify@\fR
Name of the function generating the
string representation\&.
.TP
\fB@fun_from_any@\fR
Name of the function generating the
\fBintrep\fR's internal representation from any other type, i\&.e\&. the
function to shimmer a \fBTcl_Obj*\fR to this type\&.
.TP
\fB@api_new@\fR
Name of the main constructor function\&.
See \fBnewobj\fR\&.
.TP
\fB@api_from@\fR
Name of the main retrieval function\&.
See \fBfromobj\fR\&.
.TP
\fB@intrep@\fR
Name of the C type to use for the internal
representation\&. See \fBintrep\fR\&.
.TP
\fBOT_DOUBLE(o)\fR
.TP
\fBOT_LONG(o)\fR
.TP
\fBOT_LONG2(o)\fR
.TP
\fBOT_PTR(o)\fR
.TP
\fBOT_PTR2(o)\fR
.TP
\fBOT_WIDE(o)\fR
These macros are shorthands for easy access to the various sub-fields
of the \fBinternalRep\fR of a \fBTcl_Obj*\fR\&.
Their arguments are a \fBTcl_Obj*\fR value, and the result can be
used on either side of an assignment\&.
.TP
\fBOT_STR_DUP(o,len,str)\fR
.TP
\fBOT_STR_SET(o,len,str)\fR
These macros are shorthands for setting the string representation of
an \fBTcl_Obj*\fR\&.
\fIo\fR is the \fBTcl_Obj*\fR value to modify, \fIlen\fR the integer
length of the new string, and \fIstr\fR the \fBchar*\fR value to set\&.
.sp
The \fBDUP\fR variant duplicates the \fIstr\fR before making
it the string representation of \fIo\fR, while the \fBSET\fR variant
directly assigns string and length, without copying, and leaving
memory management to the caller\&.
.TP
\fBOT_STR_DS(o,ds)\fR
This macro sets the string representation of a \fBTcl_Obj*\fR from a
\fBTcl_DString\fR value\&.
\fIo\fR is the \fBTcl_Obj*\fR value to modify, while \fIds\fR is the
\fBTcl_DString*\fR holding the string to set\&.
\fINote\fR that the macro copies the value in the
\fBTcl_DString*\fR into the object, and then release the origin\&.
.TP
\fBOT_STR_VAL(o)\fR
.TP
\fBOT_STR_LEN(o)\fR
These macros are shorthands for easy access to the string
representation of a \fBTcl_Obj*\fR, returning the \fBchar*\fR array
and length, respectively\&.
.PP
.SH EXAMPLES
.SS "SIMPLE VALUES"
This example is a slightly simplified copy of Tcl's builtin
\fBdouble\fR type\&.
.PP
The main simplicity of this \fBTcl_ObjType\fR in general is
due to the internal representation fitting into one of the predefined
fields of the \fBTcl_Obj\fR structure, voiding the need for memory
management during construction, copying, and destruction\&.
.CS


critcl::objtype define double {
    support {
	#include <stdlib\&.h> /* atof */
    }
    intrep double

    get { *value = OT_DOUBLE (obj); }

    constructor { OT_DOUBLE (obj) = value; }

    stringify {
	char buffer[TCL_DOUBLE_SPACE+1];
	int len = sprintf (buffer, "%g", OT_DOUBLE (obj));
	OT_STR_DUP (obj, len, buffer);
    }

    from-any {
	value = atof (OT_STR_VAL (obj));
    }
}

.CE
.SS "STRUCTURE VALUES"
This example does not match any of Tcl's builtin types\&.
.PP
It demonstrates the memory management needed when using an
internal representation not fitting directly into any of the
predefined field, thus requiring a pointer to the value instead\&.
.PP
In this example the \fBTcl_Obj*\fR makes a copy of incoming
structures\&. This simplifies ownership\&. The structure always belongs to
the \fBTcl_Obj*\fR, and external structures belong to the caller\&.
.PP
The example in the next section changes that so that point
structures are reference counted as well\&. This reduces memory churn,
at the expense of a bit more complicated management\&.
.CS


critcl::objtype define point {
    support {
        typedef struct point {
	    double x;
	    double y;
        } point;
    }

    intrep point*

    get { *value = (@intrep@) OT_PTR (obj); }

    constructor {
        OT_PTR (obj)    = Tcl_Alloc (sizeof (point));
        ((@intrep@) OT_PTR (obj))->x = value->x;
        ((@intrep@) OT_PTR (obj))->y = value->y;
    }

    destructor { /* Tcl_Obj* obj */
        Tcl_Free (OT_PTR (obj));
        OT_PTR (obj) = NULL;
    }

    copy { /* Tcl_Obj* obj, Tcl_Obj* dupobj */
        OT_PTR (dupobj) = Tcl_Alloc (sizeof (point));
        ((@intrep@) OT_PTR (dupobj))->x = ((@intrep@) OT_PTR (obj))->x;
        ((@intrep@) OT_PTR (dupobj))->y = ((@intrep@) OT_PTR (obj))->y;
    }

    stringify { /* Tcl_Obj* obj */
        /* Create a string rep which is usable as list\&.
	 * That makes the parsing (see below) simpler on us\&.
	 * We make it simple, no tagging\&. Just the coordinates\&.
	 */
        @intrep@ p = (@intrep@) OT_PTR (obj);
        Tcl_DString      ds;
        Tcl_DStringInit (&ds);

        char buf [TCL_DOUBLE_SPACE+1];

        Tcl_PrintDouble (0, p->x, buf); Tcl_DStringAppendElement (&ds, buf);
        Tcl_PrintDouble (0, p->y, buf); Tcl_DStringAppendElement (&ds, buf);

        OT_STR_DS (obj, &ds);
    }

    from-any { /* Tcl_Interp* interp, Tcl_Obj* obj, @intrep@ value */
        /* Shimmers incoming intrep to list, then get the elements, and
	 * at last the doubles we need out of these\&.
	 */
        Tcl_Obj** cv;
        int       cc, res;
        point     vp;

        res = Tcl_ListObjGetElements (interp, obj, &cc, &cv);
        if (res != TCL_OK) { return res; }
        if (cc != 2) {
            Tcl_AppendResult (interp, "@name@ expected exactly 2 doubles", NULL);
            return TCL_ERROR;
        }

        res = Tcl_GetDoubleFromObj (interp, cv[0], &vp\&.x);
        if (res != TCL_OK) { return res; }

        res = Tcl_GetDoubleFromObj (interp, cv[1], &vp\&.y);
        if (res != TCL_OK) { return res; }

        value = &vp;
    }
}

.CE
.SS "STRUCTURE VALUES, REFERENCE COUNTED"
This example is a variant of the example in the previous section\&.
Instead of making internal copies the structure is extended to hold a
reference count, which is then managed by constructor, copy
constructor, and destructor\&. Less memory, for the price of more
complex management\&.
.CS


critcl::objtype define point {
    support {
        typedef struct point {
            int refCount;
	    double x;
	    double y;
        } point;
    }

    intrep point*

    get { *value = (@intrep@) OT_PTR (obj); }

    constructor {
        OT_PTR (obj) = value;
        value->refCount ++;
    }

    destructor { /* Tcl_Obj* obj */
        @intrep@ value = ((@intrep@) OT_PTR (obj));
        OT_PTR (obj) = NULL;
        if (value->refCount > 1) { value->refCount --; return; }
        Tcl_Free (OT_PTR (obj));
    }

    copy { /* Tcl_Obj* obj, Tcl_Obj* dupobj */
        OT_PTR (dupobj) = OT_PTR (obj);
        ((@intrep@) OT_PTR (obj))->refCount ++;
    }

    stringify { /* Tcl_Obj* obj */
        /* Create a string rep which is usable as list\&.
	 * That makes the parsing (see below) simpler on us\&.
	 * We make it simple, no tagging\&. Just the coordinates\&.
	 */
        @intrep@ p = (@intrep@) OT_PTR (obj);
        Tcl_DString      ds;
        Tcl_DStringInit (&ds);

        char buf [TCL_DOUBLE_SPACE+1];

        Tcl_PrintDouble (0, p->x, buf); Tcl_DStringAppendElement (&ds, buf);
        Tcl_PrintDouble (0, p->y, buf); Tcl_DStringAppendElement (&ds, buf);

        OT_STR_DS (obj, &ds);
    }

    from-any { /* Tcl_Interp* interp, Tcl_Obj* obj, @intrep@ value */
        /* Shimmers incoming intrep to list, then get the elements, and
	 * at last the doubles we need out of these\&.
	 */
        Tcl_Obj** cv;
        int       cc, res;
        point     vp;

        res = Tcl_ListObjGetElements (interp, obj, &cc, &cv);
        if (res != TCL_OK) { return res; }
        if (cc != 2) {
            Tcl_AppendResult (interp, "@name@ expected exactly 2 doubles", NULL);
            return TCL_ERROR;
        }

        res = Tcl_GetDoubleFromObj (interp, cv[0], &vp\&.x);
        if (res != TCL_OK) { return res; }

        res = Tcl_GetDoubleFromObj (interp, cv[1], &vp\&.y);
        if (res != TCL_OK) { return res; }

        vp\&.refCount = 0;

        value = (@intrep@) Tcl_Alloc (sizeof (point));
        *value = vp;
    }
}

.CE
.SH AUTHORS
Andreas Kupries
.SH "BUGS, IDEAS, FEEDBACK"
This document, and the package it describes, will undoubtedly contain
bugs and other problems\&.
Please report such at \fIhttps://github\&.com/andreas-kupries/critcl\fR\&.
Please also report any ideas for enhancements you may have for either
package and/or documentation\&.
.SH KEYWORDS
C code, Embedded C Code, Tcl_Obj, Tcl_ObjType, code generator, compile & run, compiler, dynamic code generation, dynamic compilation, generate package, linker, on demand compilation, on-the-fly compilation
.SH CATEGORY
Glueing/Embedded C code
.SH COPYRIGHT
.nf
Copyright (c) 2011-2018 Andreas Kupries

.fi
