[vset VERSION 0]
[comment {-*- tcl -*- doctools manpage}]
[manpage_begin critcl::objtype n [vset VERSION]]
[include include/module2.inc]
[keywords Tcl_ObjType Tcl_Obj]
[titledesc {CriTcl Utilities: Custom Tcl_ObjTypes}]
[require Tcl 8.4]
[require critcl [opt 3.1]]
[require critcl::objtype [opt [vset VERSION]]]
[description]
[para]
[include include/welcome.inc]
[para]

This document is the reference manpage for the [package critcl::objtype]
package. This package provides convenience commands for advanced functionality
built on top of the critcl core.

[para] While Tcl comes with a variety of useful value types
([type Tcl_ObjType]) built into the core there are situations which are best
dealt by using a custom Tcl_ObjType to handle the special values it came with.

[para] With this package a developer can focus on the core handling for the
custom value, i.e. allocation, conversion into and out of strings, release,
etc., without having to deal with the boilerplate around it.

[para] It's intended audience are mainly developers wishing to write Tcl
packages with embedded C code.

[para] This package resides in the Core Package Layer of CriTcl.
[para][image arch_core][para]

[comment {===================================================================}]
[section API]

[list_begin definitions]

[comment {~ ~ ~~ ~~~ ~~~~~ ~~~~~~~~ ~~~~~~~~~~~~~ ~~~~~~~~~~~~~~~~~~~~~}]
[call [cmd {::critcl::objtype handle}] [arg name] [opt [arg option...]]]

This command creates the C code for a custom [type Tcl_ObjType] with the
specified [arg name].

[strong {By default}] it assumes the existence of a reference-counted opaque C
type of the same name, with five C functions to access the same, whose names
are derived from the name of the C type. The functions are expected to have
the signatures and behaviour given below:

[list_begin definitions]
[def "void [fun [arg name]_ref] (<name> [arg x])"]

Aquire a reference to object [arg x].

[def "void [fun [arg name]_unref] (<name> [arg x])"]

Release a reference to object [arg x]. The function has to destroy [arg x]
when its reference counts drops below [const 1].

[def "void [fun [arg name]_to_string] (<name> [arg x], Tcl_DString* [arg ds])"]

Serialize object [arg x] into the [type Tcl_DString*] variable [arg ds].
The DString is initialized and empty when the function is called.

[def "<name> [fun [arg name]_to_value] (Tcl_Interp* [arg interp], Tcl_Obj* [arg obj])"]

Deserialize (the string representation of) [arg obj] into an object of the
type and return it. The function has to return [const NULL] on error.

[def "int [fun [arg name]_refcount] (<name> [arg x])"]

Return the number of references to [arg x]. Note that the generated C code
uses this function only in [const TRACE_...] statements.

[list_end]

All of the above can be overridden by one or more option arguments following
the [arg name]. The recognized options are:

[list_begin options]
[opt_def -type [arg string]]

This option overrides the name of the C type managed by the new type. The
names of the expected functions change accordingly, if not overridden by any
of the following options.

[opt_def -ref [arg string]]
[opt_def -unref [arg string]]
[opt_def -refcount [arg string]]
[opt_def -2value [arg string]]
[opt_def -2string [arg string]]

These options override the names of the functions used to access the C type.

[opt_def -trace [arg bool]]

By default the [const TRACE...] statements embedded into the generated C code
of the new type are inactive.

This option allows them to activated. Note, this will be a source change,
affecting the package build. This is not a runtime flag.

[list_end]

[para] The result of the command is an empty string.

[para] The actual results are found in the header file generated by
the command.

[call [cmd {::critcl::objtype structure}] [arg name] [arg spec] [opt [arg option...]]]

This command creates the C code for a custom [type Tcl_ObjType] with the
specified [arg name] and the structure fields defined by the [arg spec].

[para] Internally this form is reduced to a [cmd handle], with the generator
not only emitting the boiler plate needed for the type itself, but also
emitting the code implementing the C structure and opaque type it uses.

[para] The [arg spec] is expected to be a single list of alternating type and
field names, i.e. each type name is followed by the name of field the type
applies to.

The acceptable type names are all known Critcl argument types which have an
associated [cmd critcl::argtype2string] definition. This definition specifies
how to serialize a value of the type into a [type Tcl_DString*] variable.

[para] Currently the only types doing so are a subset of the basic scalars,
namely [type int], [type long], [type boolean], [type double], and
[type float], further their aliases, and the associated sets of common range
restrictions.

[para] The nature of the string representation used for the new type is guided
by the options following [arg name] and [arg spec].

[list_begin options]
[opt_def -format [const dict]|[const list]]

This option chooses between dictionary and list representations.  In a
dictionary representation the fields are named, enabling deserialization from
any order. In the list representation the values are simply listed in their
order of specification, and deserialized in that same order.

[para] The default is [const dict].

[opt_def -tagged [arg boolean]]

This option determines if the string representation comes with a leading tag
indicating the type of the entire string value, or not.

[para] The default is [const true], i.e. [strong tagged].

[opt_def -trace [arg boolean]]

By default the [const TRACE...] statements embedded into the generated C code
of the new type are inactive.

This option allows them to activated. Note, this will be a source change,
affecting the package build. This is not a runtime flag.

[list_end]

[para] The result of the command is an empty string.

[para] The actual results are found in the header file generated by
the command.

[list_end]

[comment {===================================================================}]
[section Examples]

The examples show the various forms of specification, and for structure the
different possible string representations the generator can emit.

[subsection Handle]
[example {
    # All defaults
    critcl::objtype handle point

    # C type override
    critcl::objtype handle point -type pointxy

    # Full override, C type and function names.
    critcl::objtype handle point -type pointxy	\\
        -ref      2d_aquire			\\
        -unref    2d_release			\\
        -refcount 2d_references			\\
        -2string  2d_serialize			\\
        -2value   2d_deserialize
}]

[subsection {Structure - Tagged Dict}]
[example {
    critcl::objtype structure pointxy {
        double x
        double y
    }
    # string rep: {pointxy {x 0.0 y 0.0}}
}]

[subsection {Structure - Dict}]
[example {
    critcl::objtype structure pointxy {
        double x
        double y
    } -tagged false
    # string rep: {x 0.0 y 0.0}
}]

[subsection {Structure - Tagged List}]
[example {
    critcl::objtype structure pointxy {
        double x
        double y
    } -format list
    # string rep: {pointxy 0.0 0.0}
    #                      x   y
}]

[subsection {Structure - List}]
[example {
    critcl::objtype structure pointxy {
        double x
        double y
    } -format list -tagged false
    # string rep: {0.0 0.0}
    #              x   y
}]

[comment {===================================================================}]
[include include/feedback2.inc]
[manpage_end]
