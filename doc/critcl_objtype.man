[vset VERSION 0]
[comment {-*- tcl -*- doctools manpage}]
[manpage_begin critcl::objtype n [vset VERSION]]
[include include/module2.inc]
[keywords Tcl_ObjType Tcl_Obj]
[titledesc {CriTcl Utilities: Custom Tcl_ObjTypes}]
[require Tcl 8.4]
[require critcl [opt 3.1]]
[require critcl::objtype [opt [vset VERSION]]]
[description]
[para]
[include include/welcome.inc]
[para]

This document is the reference manpage for the [package critcl::objtype]
package. This package provides convenience commands for advanced
functionality built on top of the critcl core.

[para] While Tcl comes with a variety of useful value types
([type Tcl_ObjType]) built into the core there are situations which
are best dealt with using a custom Tcl_ObjType to handle the special
values it came with.

[para] With this package a developer can focus on the core of the
custom value handling, i.e. allocation, conversion into and out of
strings, release, without having to deal with the boilerplate around
it.

[para] Its intended audience are mainly developers wishing to write
Tcl packages with embedded C code.

[para] This package resides in the Core Package Layer of CriTcl.
[para][image arch_core][para]

[comment {===================================================================}]
[section API]

[list_begin definitions]

[comment {~ ~ ~~ ~~~ ~~~~~ ~~~~~~~~ ~~~~~~~~~~~~~ ~~~~~~~~~~~~~~~~~~~~~}]
[call [cmd {::critcl::objtype define}] [arg name] [arg script]]

This command creates C code containing a static [type Tcl_ObjType]
structure and associated functions implementing a custom value type
for Tcl.

[para] This creation is guided by the definition commands in
[arg script] specifying the various parts of the type. The available
commands are documented after this.

[para] The result of the command is an empty string.

[para] The actual results are found in the header file generated by
the command.

[comment {~ ~ ~~ ~~~ ~~~~~ ~~~~~~~~ ~~~~~~~~~~~~~ ~~~~~~~~~~~~~~~~~~~~~}]
[call [cmd support] [arg code]]

This command specifies general supporting C code for the type. The
code fragment is global, and placed between the declarations and
definitions of the Tcl_ObjType (structures, functions).

[para] The result of the command is an empty string.

[comment {~ ~ ~~ ~~~ ~~~~~ ~~~~~~~~ ~~~~~~~~~~~~~ ~~~~~~~~~~~~~~~~~~~~~}]
[call [cmd intrep] [arg name]]

This command specifies the C type to use for the internal
representation of values. The type has to be known or declared before
the function definitions. The [cmd support] command is a good place
for that, if the type is not builtin C type.

[comment {~ ~ ~~ ~~~ ~~~~~ ~~~~~~~~ ~~~~~~~~~~~~~ ~~~~~~~~~~~~~~~~~~~~~}]
[call [cmd fromobj] [arg name]]

This command specifies the name of the function extracting a C value
of type [cmd intrep] (see above) from a [type Tcl_Obj*].

[para] If not specified the generator falls back to "[arg name]FromObj"
using the [arg name] from [cmd {::critcl::objtype define}].

[para] The C signature of the function is
[example {
    int <name> (Tcl_Interp* interp, Tcl_Obj* obj, <intrep>* value);
}]

The [cmd get] command specifies the parts of the function body which
are not boilerplate.

[para] The result of the command is an empty string.

[comment {~ ~ ~~ ~~~ ~~~~~ ~~~~~~~~ ~~~~~~~~~~~~~ ~~~~~~~~~~~~~~~~~~~~~}]
[call [cmd newobj] [arg name]]

This command specifies the name of the function creating a
[type Tcl_Obj*] from a C value of type [cmd intrep] (see above).

[para] If not specified the generator falls back to "[arg name]NewObj"
using the [arg name] from [cmd {::critcl::objtype define}].

[para] The C signature of the function is
[example {
    Tcl_Obj* <name> (<intrep>* value);
}]

The [cmd constructor] command specifies the parts of the function body
which are not boilerplate.

[para] The result of the command is an empty string.


[comment {~ ~ ~~ ~~~ ~~~~~ ~~~~~~~~ ~~~~~~~~~~~~~ ~~~~~~~~~~~~~~~~~~~~~}]
[call [cmd api] [arg name]]

This command is a convenience command performing the actions of both
[cmd fromobj] and [cmd newobj].

[para] The result of the command is an empty string.


[comment {~ ~ ~~ ~~~ ~~~~~ ~~~~~~~~ ~~~~~~~~~~~~~ ~~~~~~~~~~~~~~~~~~~~~}]
[call [cmd constructor] [arg code]]

This command specifies how a C value of type [cmd intrep] is converted
into a [type Tcl_Obj*].

This is the part of the [cmd newobj] function which is not boiler
plate.

[para] The code has access to the two variables [var obj] and
[var value]. The first refers to a newly allocated [type Tcl_Obj*] to
fill, and the second contains the value to convert.

[para] If this code is not specified the generator falls back to
casting the value to a [type void*] before copying it into the
[var ptr1] field of the [type Tcl_Obj*].

[para] The result of the command is an empty string.


[comment {~ ~ ~~ ~~~ ~~~~~ ~~~~~~~~ ~~~~~~~~~~~~~ ~~~~~~~~~~~~~~~~~~~~~}]
[call [cmd get] [arg code]]

This command specifies how a C value of type [cmd intrep] is retrieved
from a [type Tcl_Obj*].

This is the part of the [cmd fromobj] function which is not boiler
plate.

[para] The code has access to the three variables [var interp],
[var obj] and [var value].  The first is a [type Tcl_Interp*] of the
interpreter we are in, the second is the [type Tcl_Obj*] we query, and
the last a pointer to the destination to store the retrieved value
into.

[para] If this code is not specified the generator falls back to
casting the value of the [var obj]'s [var ptr1] to the [cmd intrep]
type and then copying the result to the destination.

[para] Note that shimmering the [var obj] to this type, if it does
not have that type, is part of the standard behaviour of the function.
This makes use of the conversion code specified by [cmd parse].

[para] The result of the command is an empty string.


[comment {~ ~ ~~ ~~~ ~~~~~ ~~~~~~~~ ~~~~~~~~~~~~~ ~~~~~~~~~~~~~~~~~~~~~}]
[call [cmd copy] [arg code]]

This command specifies how a [type Tcl_Obj*] of this type is
duplicated, i.e. copied.

[para] The code has access to two variables, [var obj] and
[var dupobj]. The first references the [type Tcl_Obj*] to duplicate,
and the second references a newly allocated, empty [type Tcl_Obj*] to
fill with the duplicated [cmd intrep].

[para] If this code is not specified the copy constructor is left as
[const NULL] and the Tcl core standard behaviour applies, which simply
copies the intrep over.

[para] The result of the command is an empty string.


[comment {~ ~ ~~ ~~~ ~~~~~ ~~~~~~~~ ~~~~~~~~~~~~~ ~~~~~~~~~~~~~~~~~~~~~}]
[call [cmd destructor] [arg code]]

This command specifies how a [type Tcl_Obj*] of this type releases it
[cmd intrep] when the core destroys it.

[para] The code has access to a single variable, [var obj], which
references the [type Tcl_Obj*] being released.

[para] If this code is not specified the destructor is left as
[const NULL] and the Tcl core standard behaviour applies, which simply
does nothing.

[para] The result of the command is an empty string.


[comment {~ ~ ~~ ~~~ ~~~~~ ~~~~~~~~ ~~~~~~~~~~~~~ ~~~~~~~~~~~~~~~~~~~~~}]
[call [cmd stringify] [arg code]]

This command specifies how to construct a string representation
from the [cmd intrep] of this type.

[para] The code has access to a single variable, [var obj], which
references the [type Tcl_Obj*] whose string representation has to be
filled in.

[para] If this code is not specified then [emph nothing] is done. In
other words, values of this type have no string representation.  This
not only prevents printing such values, but also the conversion to any
other [type Tcl_ObjType] using an intermediate string representation
as part of shimmering to it.

[para] Note the supporting macros [fun OT_STR_SET], [fun OT_STR_DUP],
and [fun OT_STR_DS]. See the [sectref {Supporting definitions}].

[para] The result of the command is an empty string.


[comment {~ ~ ~~ ~~~ ~~~~~ ~~~~~~~~ ~~~~~~~~~~~~~ ~~~~~~~~~~~~~~~~~~~~~}]
[call [cmd from-any] [arg code]]

This command specifies how to shimmer a [type Tcl_Obj*] from whatever
current type it has to this type.

[para] The code has access to the three variables [var interp],
[var obj] and [var value].  The first is a [type Tcl_Interp*] of the
interpreter we are in, the second is the [type Tcl_Obj*] to shimmer,
and the last is the place where to construct the new [cmd intrep].

[para] The function using this code will call this first before
releasing the old internal representation and at last using the
[cmd constructor] code to store the new internal representation found
in [var value] into the object.

[para] The result of the command is an empty string.


[comment {~ ~ ~~ ~~~ ~~~~~ ~~~~~~~~ ~~~~~~~~~~~~~ ~~~~~~~~~~~~~~~~~~~~~}]
[call [cmd stubs]]

This command tells the generator that the [cmd fromobj] and
[cmd newobj] functions of this type are to be made public,
i.e. exported through the stubs table of the package the code will be
made a part of.

[list_end]

[comment {===================================================================}]
[section {Supporting definitions}]

All [arg code] argument not only have access to the variables listed
in their documentation above, the definitions from the [cmd support]
cmd, but also to

[list_begin definitions]

[def [const @have_destructor@]] Boolean ([const 0]/[const 1]).
True indicates that the [cmd destructor] was specified.

[def [const @have_copy@]] Boolean ([const 0]/[const 1]).
True indicates that the [cmd copy] constructor was specified.

[def [const @fun_destructor@]] Name of the destructor function.

[def [const @fun_copy@]] Name of the copy constructor function.

[def [const @fun_stringify@]] Name of the function generating the
string representation.

[def [const @fun_from_any@]] Name of the function generating the
[cmd intrep]'s internal representation from any other type, i.e. the
function to shimmer a [type Tcl_Obj*] to this type.

[def [const @api_new@]] Name of the main constructor function.
See [cmd newobj].

[def [const @api_from@]] Name of the main retrieval function.
See [cmd fromobj].

[def [const @intrep@]] Name of the C type to use for the internal
representation. See [cmd intrep].

[def [fun OT_DOUBLE(o)]]
[def [fun OT_LONG(o)]]
[def [fun OT_LONG2(o)]]
[def [fun OT_PTR(o)]]
[def [fun OT_PTR2(o)]]
[def [fun OT_WIDE(o)]]

These macros are shorthands for easy access to the various sub-fields
of the [var internalRep] of a [type Tcl_Obj*].

Their arguments are a [type Tcl_Obj*] value, and the result can be
used on either side of an assignment.

[def [fun OT_STR_DUP(o,len,str)]]
[def [fun OT_STR_SET(o,len,str)]]

These macros are shorthands for setting the string representation of
an [type Tcl_Obj*].

[arg o] is the [type Tcl_Obj*] value to modify, [arg len] the integer
length of the new string, and [arg str] the [type char*] value to set.

[para] The [const DUP] variant duplicates the [arg str] before making
it the string representation of [arg o], while the [const SET] variant
directly assigns string and length, without copying, and leaving
memory management to the caller.

[def [fun OT_STR_DS(o,ds)]]

This macro sets the string representation of a [type Tcl_Obj*] from a
[type Tcl_DString] value.

[arg o] is the [type Tcl_Obj*] value to modify, while [arg ds] is the
[type Tcl_DString*] holding the string to set.

[strong Note] that the macro copies the value in the
[type Tcl_DString*] into the object, and then release the origin.

[def [fun OT_STR_VAL(o)]]
[def [fun OT_STR_LEN(o)]]

These macros are shorthands for easy access to the string
representation of a [type Tcl_Obj*], returning the [type char*] array
and length, respectively.

[list_end]


[comment {===================================================================}]
[section Examples]

[subsection {Simple Values}]

This example is a slightly simplified copy of Tcl's builtin
[type double] type.

[para] The main simplicity of this [type Tcl_ObjType] in general is
due to the internal representation fitting into one of the predefined
fields of the [type Tcl_Obj] structure, voiding the need for memory
management during construction, copying, and destruction.

[example {
critcl::objtype define double {
    support {
	#include <stdlib.h> /* atof */
    }
    intrep double

    get { *value = OT_DOUBLE (obj); }

    constructor { OT_DOUBLE (obj) = value; }

    stringify {
	char buffer[TCL_DOUBLE_SPACE+1];
	int len = sprintf (buffer, "%g", OT_DOUBLE (obj));
	OT_STR_DUP (obj, len, buffer);
    }

    from-any {
	value = atof (OT_STR_VAL (obj));
    }
}
}]


[subsection {Structure Values}]

This example does not match any of Tcl's builtin types.

[para] It demonstrates the memory management needed when using an
internal representation not fitting directly into any of the
predefined field, thus requiring a pointer to the value instead.

[para] In this example the [type Tcl_Obj*] makes a copy of incoming
structures. This simplifies ownership. The structure always belongs to
the [type Tcl_Obj*], and external structures belong to the caller.

[para] The example in the next section changes that so that point
structures are reference counted as well. This reduces memory churn,
at the expense of a bit more complicated management.

[example {
critcl::objtype define point {
    support {
        typedef struct point {
	    double x;
	    double y;
        } point;
    }

    intrep point*

    get { *value = (@intrep@) OT_PTR (obj); }

    constructor {
        OT_PTR (obj)    = Tcl_Alloc (sizeof (point));
        ((@intrep@) OT_PTR (obj))->x = value->x;
        ((@intrep@) OT_PTR (obj))->y = value->y;
    }

    destructor { /* Tcl_Obj* obj */
        Tcl_Free (OT_PTR (obj));
        OT_PTR (obj) = NULL;
    }

    copy { /* Tcl_Obj* obj, Tcl_Obj* dupobj */
        OT_PTR (dupobj) = Tcl_Alloc (sizeof (point));
        ((@intrep@) OT_PTR (dupobj))->x = ((@intrep@) OT_PTR (obj))->x;
        ((@intrep@) OT_PTR (dupobj))->y = ((@intrep@) OT_PTR (obj))->y;
    }

    stringify { /* Tcl_Obj* obj */
        /* Create a string rep which is usable as list.
	 * That makes the parsing (see below) simpler on us.
	 * We make it simple, no tagging. Just the coordinates.
	 */
        @intrep@ p = (@intrep@) OT_PTR (obj);
        Tcl_DString      ds;
        Tcl_DStringInit (&ds);

        char buf [TCL_DOUBLE_SPACE+1];

        Tcl_PrintDouble (0, p->x, buf); Tcl_DStringAppendElement (&ds, buf);
        Tcl_PrintDouble (0, p->y, buf); Tcl_DStringAppendElement (&ds, buf);

        OT_STR_DS (obj, &ds);
    }

    from-any { /* Tcl_Interp* interp, Tcl_Obj* obj, @intrep@ value */
        /* Shimmers incoming intrep to list, then get the elements, and
	 * at last the doubles we need out of these.
	 */
        Tcl_Obj** cv;
        int       cc, res;
        point     vp;

        res = Tcl_ListObjGetElements (interp, obj, &cc, &cv);
        if (res != TCL_OK) { return res; }
        if (cc != 2) {
            Tcl_AppendResult (interp, "@name@ expected exactly 2 doubles", NULL);
            return TCL_ERROR;
        }

        res = Tcl_GetDoubleFromObj (interp, cv[0], &vp.x);
        if (res != TCL_OK) { return res; }

        res = Tcl_GetDoubleFromObj (interp, cv[1], &vp.y);
        if (res != TCL_OK) { return res; }

        value = &vp;
    }
}
}]


[subsection {Structure values, reference counted}]

This example is a variant of the example in the previous section.
Instead of making internal copies the structure is extended to hold a
reference count, which is then managed by constructor, copy
constructor, and destructor. Less memory, for the price of more
complex management.

[example {
critcl::objtype define point {
    support {
        typedef struct point {
            int refCount;
	    double x;
	    double y;
        } point;
    }

    intrep point*

    get { *value = (@intrep@) OT_PTR (obj); }

    constructor {
        OT_PTR (obj) = value;
        value->refCount ++;
    }

    destructor { /* Tcl_Obj* obj */
        @intrep@ value = ((@intrep@) OT_PTR (obj));
        OT_PTR (obj) = NULL;
        if (value->refCount > 1) { value->refCount --; return; }
        Tcl_Free (OT_PTR (obj));
    }

    copy { /* Tcl_Obj* obj, Tcl_Obj* dupobj */
        OT_PTR (dupobj) = OT_PTR (obj);
        ((@intrep@) OT_PTR (obj))->refCount ++;
    }

    stringify { /* Tcl_Obj* obj */
        /* Create a string rep which is usable as list.
	 * That makes the parsing (see below) simpler on us.
	 * We make it simple, no tagging. Just the coordinates.
	 */
        @intrep@ p = (@intrep@) OT_PTR (obj);
        Tcl_DString      ds;
        Tcl_DStringInit (&ds);

        char buf [TCL_DOUBLE_SPACE+1];

        Tcl_PrintDouble (0, p->x, buf); Tcl_DStringAppendElement (&ds, buf);
        Tcl_PrintDouble (0, p->y, buf); Tcl_DStringAppendElement (&ds, buf);

        OT_STR_DS (obj, &ds);
    }

    from-any { /* Tcl_Interp* interp, Tcl_Obj* obj, @intrep@ value */
        /* Shimmers incoming intrep to list, then get the elements, and
	 * at last the doubles we need out of these.
	 */
        Tcl_Obj** cv;
        int       cc, res;
        point     vp;

        res = Tcl_ListObjGetElements (interp, obj, &cc, &cv);
        if (res != TCL_OK) { return res; }
        if (cc != 2) {
            Tcl_AppendResult (interp, "@name@ expected exactly 2 doubles", NULL);
            return TCL_ERROR;
        }

        res = Tcl_GetDoubleFromObj (interp, cv[0], &vp.x);
        if (res != TCL_OK) { return res; }

        res = Tcl_GetDoubleFromObj (interp, cv[1], &vp.y);
        if (res != TCL_OK) { return res; }

        vp.refCount = 0;

        value = (@intrep@) Tcl_Alloc (sizeof (point));
        *value = vp;
    }
}
}]

[comment {===================================================================}]
[include include/feedback2.inc]
[manpage_end]
